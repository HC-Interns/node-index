// Generated by CoffeeScript 2.3.1
(function () {
  /*
    Bulk set/unset functionality for Node index module
     This software is licensed under the MIT License.
     Copyright Fedor Indutny, 2011.
     Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to permit
    persons to whom the Software is furnished to do so, subject to the
    following conditions:
     The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.
     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
  var splitPage, step, utils;

  step = require('step');

  utils = require('../../index/utils');

  /*
    Bulk set/unset
     kvs = [
      [key, value, 1] - set
      [key] - unset
    ]
  */
  exports.bulk = function (kvs, _callback) {
    var callback, conflictManager, conflicts, iterate, order, recSplit, sort, storage, that;
    that = this;
    sort = this.sort;
    order = this.order;
    storage = this.storage;
    conflictManager = this.conflictManager;
    if (this.lock(() => {
      return this.bulk(kvs, _callback);
    })) {
      return;
    }
    callback = (err, data) => {
      this.releaseLock();
      return process.nextTick(function () {
        return _callback && _callback(err, conflicts);
      });
    };
    // conflicts
    conflicts = [];
    // clone kvs
    kvs = [].concat(kvs);
    // sort kvs
    kvs = kvs.sort(function (a, b) {
      return sort(a[0], b[0]);
    });
    if (!(kvs.length > 0)) {
      return callback(null, []);
    }
    // do bulk ops on page
    // kvs is part of original kvs that matches page range
    // (range is stored in parent page of course)

    // return values
    //   null, [array of kps] = [ [null, pos], [key1, pos], ...]
    //   null, []
    iterate = function (callback, kvs) {
      var _iterate;
      return _iterate = function (err, page) {
        var _kvs, index, item, kv, kv_index;
        if (err) {
          return callback(err);
        }
        kv = kvs.shift();
        if (!kv) {
          // all kvs has been processed split or delete page
          splitPage(page, order, storage, callback);
          return;
        }
        index = utils.search(page, sort, kv[0]);
        item = page[index];
        if (item && !item[2]) {
          // index page
          kvs.unshift(kv);
          if (page[index + 1]) {
            kv_index = utils.search(kvs, sort, page[index + 1][0]);
            if (!kvs[kv_index]) {
              kv_index++;
            } else if (sort(kvs[kv_index][0], page[index + 1][0]) !== 0) {
              kv_index++;
            }
            _kvs = kvs.splice(0, kv_index);
          } else {
            _kvs = kvs;
          }
          return step(function () {
            return storage.read(item[1], this.parallel());
          }, iterate(function (err, kps) {
            if (err) {
              return callback(err);
            }
            if (kps.length === 0) {
              page.splice(index, 1);
            } else {
              kps[0][0] = item[0];
              page.splice.apply(page, [index, 1].concat(kps));
            }
            return _iterate(null, page);
          }, _kvs));
        } else {
          // leaf page
          // so insert all kvs here
          // and remove
          if (!item || sort(item[0], kv[0]) < 0) {
            if (kv[2]) {
              // just insert item and continue iterating
              index = index === null ? 0 : index + 1;
              page.splice(index, 0, kv);
              storage.write([kv[1]], function (err, pos) {
                kv[1] = pos;
                return process.nextTick(function () {
                  return _iterate(null, page);
                });
              });
              return;
            } else {}
          } else {
            // ok, item exists
            // do nothing, b/c item not found and we can't delete it
            if (!kv[2]) {
              // if we're removing that's ok
              // just remove
              page.splice(index, 1);
            } else {
              // manage conflicts if inserting
              if (conflictManager) {
                // TODO: write conflictManager
                conflicts.push(kv[0]);
              } else {
                conflicts.push(kv[0]);
              }
            }
          }
          return process.nextTick(function () {
            return _iterate(null, page);
          });
        }
      };
    };
    return step(function () {
      return storage.readRoot(this.parallel());
    }, iterate(recSplit = function (err, page) {
      if (err) {
        return callback(err);
      }
      if (page.length === 0) {
        return storage.write([], function (err, pos) {
          if (err) {
            return callback(err);
          }
          return storage.writeRoot(pos, callback);
        });
      } else if (page.length === 1) {
        return storage.writeRoot(page[0][1], callback);
      } else {
        return splitPage(page, order, storage, recSplit);
      }
    }, kvs));
  };

  splitPage = function (page, order, storage, callback) {
    var i, len, pages;
    if (page.length === 0) {
      pages = [];
    } else if (page.length <= order) {
      pages = [page];
    } else {
      pages = [];
      i = 0;
      len = page.length;
      while (len > order) {
        len = len >> 1;
      }
      while (page.length > 0) {
        pages.push(page.splice(0, len));
      }
    }
    return step(function () {
      var group, j, len1, pre_page;
      group = this.group();
      for (j = 0, len1 = pages.length; j < len1; j++) {
        page = pages[j];
        pre_page = [].concat(page);
        if (!page[0][2]) {
          pre_page[0] = [].concat(pre_page[0]);
          pre_page[0][0] = null;
        }
        storage.write(pre_page, group());
      }
    }, function (err, pages_pos) {
      if (err) {
        return callback(err);
      }
      pages = pages_pos.map(function (pos, i) {
        if (i === 0) {
          return [null, pos];
        } else {
          return [pages[i][0][0], pos];
        }
      });
      return this.parallel()(null, pages);
    }, callback);
  };
}).call(this);
// Generated by CoffeeScript 2.3.1
(function () {
  /*
    Compaction for Node Index
     This software is licensed under the MIT License.
     Copyright Fedor Indutny, 2011.
     Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to permit
    persons to whom the Software is furnished to do so, subject to the
    following conditions:
     The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.
     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
  var step, utils;

  step = require('step');

  utils = require('../../index/utils');

  exports.compact = function (_callback) {
    var callback, iterate, storage;
    storage = this.storage;
    callback = (err, data) => {
      this.releaseLock();
      return process.nextTick(function () {
        return _callback && _callback(err, data);
      });
    };
    if (this.lock(() => {
      return this.compact(_callback);
    })) {
      return;
    }
    iterate = function (callback) {
      return function (err, page) {
        var fns, in_leaf;
        if (err) {
          return callback(err);
        }
        in_leaf = page[0] && page[0][2];
        fns = page.map(function (item) {
          return function () {
            return step(function () {
              storage.read(item[1], this.parallel(), in_leaf);
            }, function (err, data) {
              if (err) {
                throw err;
              }
              if (in_leaf) {
                // data is actual value
                storage.write(data, this.parallel(), in_leaf);
                return;
              }
              iterate(this.parallel())(null, data);
            }, function (err, new_pos) {
              if (err) {
                throw err;
              }
              item[1] = new_pos;
              this.parallel()(null);
            }, this.parallel());
          };
        });
        fns.push(function (err) {
          if (err) {
            throw err;
          }
          storage.write(page, this.parallel());
        });
        fns.push(callback);
        return step.apply(null, fns);
      };
    };
    return step(function () {
      // will allow storage controller
      // to prepare it for
      if (storage.beforeCompact) {
        storage.beforeCompact(this.parallel());
      } else {
        this.parallel()(null);
      }
    }, function (err) {
      if (err) {
        throw err;
      }
      storage.readRoot(iterate(this.parallel()));
    }, function (err, new_root_pos) {
      if (err) {
        throw err;
      }
      storage.writeRoot(new_root_pos, this.parallel());
    }, function (err) {
      if (err) {
        throw err;
      }
      // @will allow storage to finalize all actions
      if (storage.afterCompact) {
        storage.afterCompact(this.parallel());
      } else {
        this.parallel()(null);
      }
    }, callback);
  };
}).call(this);
// Generated by CoffeeScript 2.3.1
(function () {
  /*
    Get functionality for Node Index module
     This software is licensed under the MIT License.
     Copyright Fedor Indutny, 2011.
     Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to permit
    persons to whom the Software is furnished to do so, subject to the
    following conditions:
     The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.
     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
  var step, utils;

  utils = require('../../index/utils');

  step = require('step');

  /*
    Get value by key
  */
  exports.get = function (key, callback) {
    var iterate, sort, storage;
    sort = this.sort;
    storage = this.storage;
    iterate = function (err, index) {
      var item, item_index, value;
      if (err) {
        return callback(err);
      }
      item_index = utils.search(index, sort, key);
      item = index[item_index];
      // Item not found
      if (!item) {
        return callback('Not found');
      }
      value = item[1];
      if (item[2]) {
        // Key Value - return value
        if (sort(item[0], key) !== 0) {
          return callback('Not found');
        }
        // Read actual value
        return storage.read(value, function (err, value) {
          if (err) {
            return callback(err);
          }
          // value = [value, link-to-previous-value]
          return callback(null, value[0]);
        });
      } else {
        // Key Pointer - go further
        return storage.read(value, iterate);
      }
    };
    return storage.readRoot(iterate);
  };

  /*
  Traverse btree
  filter can call callback w/ following result:
    true - if `traverse` should go deeper
    undefined - if `traverse` should skip element
    false - if `traverse` should stop traversing and return to higher level
   filter can
  @return promise.
  */
  exports.traverse = function (filter) {
    var promise, that;
    that = this;
    promise = new process.EventEmitter();
    // If no filter were provided - match all
    filter = filter || function (kp, callback) {
      return callback(null, true);
    };
    process.nextTick(() => {
      var iterate, sort, storage;
      sort = this.sort;
      storage = this.storage;
      iterate = function (callback) {
        return function (err, page) {
          var asyncFilter, index, pagelen;
          if (err) {
            promise.emit('error', err);
            promise.emit('end');
            return;
          }
          index = -1;
          pagelen = page.length;
          asyncFilter = function () {
            var current;
            if (++index >= pagelen) {
              if (callback) {
                callback(null);
              } else {
                promise.emit('end');
              }
              return;
            }
            current = page[index];
            return filter.call(that, current, function (err, filter_value) {
              if (filter_value === true) {
                if (current[2]) {
                  // emit value
                  return storage.read(current[1], function (err, value) {
                    // value = [value, link-to-previous-value]
                    promise.emit('data', value[0], current);
                    return asyncFilter();
                  });
                } else {
                  // go deeper
                  return storage.read(current[1], iterate(asyncFilter));
                }
              } else {
                if (filter_value === false) {
                  index = pagelen;
                }
                return asyncFilter();
              }
            });
          };
          return asyncFilter();
        };
      };
      return storage.readRoot(iterate());
    });
    return promise;
  };

  /*
  Get in range
  */
  exports.rangeGet = function (start_key, end_key) {
    var promise, sort, traverse_promise;
    sort = this.sort;
    promise = new process.EventEmitter();
    traverse_promise = this.traverse(function (kp, callback) {
      var end_cmp, start_cmp;
      start_cmp = sort(kp[0], start_key);
      end_cmp = sort(kp[0], end_key);
      if (kp[2]) {
        if (start_cmp >= 0 && end_cmp <= 0) {
          return callback(null, true);
        }
        if (end_cmp > 0) {
          return callback(null, false);
        }
      } else {
        if (end_cmp <= 0) {
          return callback(null, true);
        }
        if (end_cmp > 0) {
          return callback(null, false);
        }
      }
      return callback(null);
    });
    traverse_promise.on('data', function (value) {
      return promise.emit('data', value);
    });
    traverse_promise.on('end', function () {
      return promise.emit('end');
    });
    return promise;
  };
}).call(this);
// Generated by CoffeeScript 2.3.1
(function () {
  /*
    Set functionality for Node index module
     This software is licensed under the MIT License.
     Copyright Fedor Indutny, 2011.
     Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to permit
    persons to whom the Software is furnished to do so, subject to the
    following conditions:
     The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.
     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
  /*
  Check page length
  If exceed - split it into two and return left_page, right_page, middle_key
  */
  var splitPage, step, utils;

  step = require('step');

  utils = require('../../index/utils');

  /*
    Set
  */
  exports.set = function (key, value, _callback) {
    var callback, conflictManager, iterate, order, sort, storage;
    sort = this.sort;
    order = this.order;
    storage = this.storage;
    conflictManager = this.conflictManager;
    if (this.lock(() => {
      return this.set(key, value, _callback);
    })) {
      return;
    }
    callback = (err, data) => {
      this.releaseLock();
      return process.nextTick(function () {
        return _callback && _callback(err, data);
      });
    };
    iterate = function (page, callback) {
      var item, item_index;
      item_index = utils.search(page, sort, key);
      item = page[item_index];
      if (item && !item[2]) {
        // Index

        // Read next page and try to insert kv in it
        return step(function () {
          return storage.read(item[1], this.parallel());
        }, function (err, page) {
          if (err) {
            throw err;
          }
          return iterate(page, this.parallel());
        }, function (err, result) {
          if (err) {
            callback(err);
            return;
          }
          if (storage.isPosition(result)) {
            // Page is just should be overwrited
            page[item_index][1] = result;
            return storage.write(page, callback);
          } else {
            //  Result is = {
            //    left_page: [...],
            //    middle_key: ...,
            //    right_page: [...]
            //  }
            page[item_index][1] = result.left_page;
            page.splice(item_index + 1, 0, [result.middle_key, result.right_page]);
            return splitPage(false, storage, order, page, callback);
          }
        });
      } else {
        // Leaf
        return step(function () {
          // Found dublicate
          if (item && sort(item[0], key) === 0) {
            if (!conflictManager) {
              throw 'Can\'t insert item w/ dublicate key';
            }
            // Invoke conflictManager
            step(function () {
              return storage.read(item[1], this.parallel());
            }, function (err, old_value) {
              if (err) {
                throw err;
              }
              this.parallel()(null, old_value);
              return conflictManager(old_value, value, this.parallel());
            }, this.parallel());
            return;
          }
          return this.parallel()(null, value);
        }, function (err, value, old_value) {
          if (err) {
            throw err;
          }
          // Value should be firstly written in storage
          item_index = item_index === null ? 0 : item_index + 1;
          return storage.write([value, old_value], this.parallel());
        }, function (err, value) {
          if (err) {
            callback(err);
            return;
          }
          // Then inserted in leaf page
          page.splice(item_index, 0, [key, value, 1]);
          return splitPage(true, storage, order, page, callback);
        });
      }
    };
    return step(function () {
      // Read initial data
      return storage.readRoot(this.parallel());
    }, function (err, root) {
      if (err) {
        throw err;
      }
      // Initiate sequence
      return iterate(root, this.parallel());
    }, function (err, result) {
      if (err) {
        throw err;
      }
      if (storage.isPosition(result)) {
        // Write new root
        return this.parallel()(null, result);
      } else {
        // Split root
        return storage.write([[null, result.left_page], [result.middle_key, result.right_page]], this.parallel());
      }
    }, function (err, new_root_pos) {
      if (err) {
        throw err;
      }
      return storage.writeRoot(new_root_pos, this.parallel());
    }, callback);
  };

  splitPage = function (in_leaf, storage, order, page, callback) {
    var mid_index, mid_key;
    // If item needs to be splitted
    if (page.length > order) {
      mid_index = page.length >> 1;
      mid_key = page[mid_index][0];
      // Write splitted pages
      return step(function () {
        var left_page, right_page;
        left_page = page.slice(0, mid_index);
        storage.write(left_page, this.parallel());
        right_page = page.slice(mid_index);
        if (!in_leaf) {
          right_page[0][0] = null;
        }
        return storage.write(right_page, this.parallel());
      }, function (err, left_page, right_page) {
        return callback(err, {
          left_page: left_page,
          middle_key: mid_key,
          right_page: right_page
        });
      });
    } else {
      // Just overwrite it
      return storage.write(page, callback);
    }
  };
}).call(this);
// Generated by CoffeeScript 2.3.1
(function () {
  /*
    Unset functionality for Node index module
     This software is licensed under the MIT License.
     Copyright Fedor Indutny, 2011.
     Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to permit
    persons to whom the Software is furnished to do so, subject to the
    following conditions:
     The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.
     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
  var step, utils;

  step = require('step');

  utils = require('../../index/utils');

  exports.unset = function (key, _callback) {
    var callback, iterate, sort, storage;
    callback = (err, data) => {
      this.releaseLock();
      return process.nextTick(function () {
        return _callback && _callback(err, data);
      });
    };
    storage = this.storage;
    sort = this.sort;
    if (this.lock(() => {
      return this.unset(key, _callback);
    })) {
      return;
    }
    iterate = function (page, callback) {
      var item, item_index;
      item_index = utils.search(page, sort, key);
      item = page[item_index];
      if (item_index === null) {
        // Not found
        // Even in that case unset should be successfull
        callback(null);
        return;
      }
      if (item[2]) {
        // Leaf
        if (sort(item[0], key) !== 0) {
          // Actually key doesn't match
          // So do nothing
          callback(null);
          return;
        }
        // Delete from leaf and if one will be empty
        // remove leaf from parent
        page.splice(item_index, 1);
        if (page.length > 0) {
          // If resulting page isn't empty
          step(function () {
            return storage.write(page, this.parallel());
          }, callback);
          return;
        }
        // Notify that item should be removed from parent index
        return callback(null, false);
      } else {
        // Index page
        return step(function () {
          return storage.read(item[1], this.parallel());
        }, function (err, page) {
          if (err) {
            throw err;
          }
          return iterate(page, this.parallel());
        }, function (err, result) {
          if (err) {
            callback(err);
            return;
          }
          if (result === false) {
            // Delete item from index page
            page.splice(item_index, 1);
            if (page.length <= 1) {
              callback(null, page[0][1]);
              return;
            }
          } else if (storage.isPosition(result)) {
            page[item_index][1] = result;
          } else {
            callback(null);
            return;
          }
          return step(function () {
            return storage.write(page, this.parallel());
          }, callback);
        });
      }
    };
    return step(function () {
      return storage.readRoot(this.parallel());
    }, function (err, root) {
      if (err) {
        throw err;
      }
      return iterate(root, this.parallel());
    }, function (err, result) {
      if (err) {
        throw err;
      }
      if (result === false) {
        // Create new root
        return storage.write([], this.parallel());
      } else if (storage.isPosition(result)) {
        // Overwrite old root
        return this.parallel()(null, result);
      } else {
        return this.parallel()(null);
      }
    }, function (err, position) {
      if (err) {
        throw err;
      }
      if (storage.isPosition(position)) {
        return storage.writeRoot(position, this.parallel());
      } else {
        return this.parallel()(null);
      }
    }, callback);
  };
}).call(this);
// Generated by CoffeeScript 2.3.1
(function () {
  /*
    File storage for Node Index Module
     This software is licensed under the MIT License.
     Copyright Fedor Indutny, 2011.
     Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to permit
    persons to whom the Software is furnished to do so, subject to the
    following conditions:
     The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.
     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
  /*
    Default storage options
  */
  /*
  Class @constructor
  */
  var Buffer, DEFAULT_OPTIONS, Storage, fs, isPosition, packer, path, step, utils;

  utils = require('./utils');

  step = require('step');

  fs = require('fs');

  path = require('path');

  packer = {
    pack: function (data) {
      var result, size;
      data = JSON.stringify(data);
      size = Buffer.byteLength(data);
      result = new Buffer(size + 4);
      // Put size
      result.writeUInt32LE(size, 0);
      // Put data
      result.write(data, 4);
      // Return result
      return result;
    },
    unpack: function (data) {
      var size;
      size = data.readUInt32LE(0);
      return JSON.parse(data.slice(4, 4 + size).toString());
    }
  };

  Buffer = require('buffer').Buffer;

  DEFAULT_OPTIONS = {
    filename: '',
    padding: 8,
    rootSize: 64,
    partitionSize: 1024 * 1024 * 1024,
    flushMinBytes: 4 * 1024 * 1024
  };

  Storage = exports.Storage = function (options, callback) {
    options = utils.merge(DEFAULT_OPTIONS, options);
    if (!options.filename) {
      return callback('Filename is required');
    }
    ({ filename: this.filename, padding: this.padding, partitionSize: this.partitionSize, rootSize: this.rootSize, flushMinBytes: this.flushMinBytes } = options);
    this._init(callback);
    return this;
  };

  /*
  Initializes storage
  May be used not from constructor
  */
  Storage.prototype._init = function (callback) {
    this.files = [];
    this.filesOffset = 0;
    this.buffers = [];
    this.buffersBytes = 0;
    this.buffersHashmap = {};
    return this.checkCompaction(err => {
      if (err) {
        return callback(err);
      }
      return this.openFile(err => {
        if (err) {
          return callback(err);
        }
        if (this.files.length <= 0) {
          // If no files - create one
          return this.createFile(callback);
        } else {
          return callback(null, this);
        }
      });
    });
  };

  /*
    @constructor wrapper
  */
  exports.createStorage = function (options, callback) {
    return new Storage(options, callback);
  };

  /*
  pos = [
    start-offset,
    length
    file-index or undefined
  ]
  */
  Storage.prototype.isPosition = isPosition = function (pos) {
    return pos != null && Array.isArray(pos) && pos.length === 3 && true;
  };

  /*
  Adds index to the end of file
  and return next (unopened) filename
  */
  Storage.prototype.nextFilename = function (i, filename) {
    var index;
    index = i || this.files.length;
    index -= this.filesOffset;
    filename = filename || this.filename;
    if (index > 0) {
      return filename + '.' + index;
    } else {
      return filename;
    }
  };

  /*
    Check if interrupted compaction is in place
  */
  Storage.prototype.checkCompaction = function (callback) {
    var filename, nextFilename;
    filename = this.filename;
    nextFilename = this.nextFilename.bind(this);
    return path.exists(filename, exists => {
      return path.exists(filename + '.compact', compactExists => {
        if (exists) {
          if (compactExists) {
            // Probably compaction hasn't finished
            // Delete compaction files
            this.iterateFiles(filename + '.compact', function (err, i) {
              var compacted;
              if (err) {
                throw err;
              }
              if (i !== null) {
                compacted = nextFilename(i, filename + '.compact');
                return fs.unlink(compacted, this.parallel());
              } else {
                return this.parallel()(null);
              }
            });
          }
          // Normal db file exists - use it
          return callback(null);
        } else {
          if (compactExists) {
            // Ok, compaction has finished
            // Move files
            return this.iterateFiles(filename + '.compact', function (err, i) {
              var _callback, compacted, notcompacted;
              if (err) {
                throw err;
              }
              if (i !== null) {
                // still iterating
                compacted = nextFilename(i, filename + '.compact');
                notcompacted = nextFilename(i, filename);
                _callback = this.parallel();
                return fs.unlink(notcompacted, function (err) {
                  if (err && (!err.code || err.code !== 'ENOENT')) {
                    return _callback(err);
                  } else {
                    return fs.rename(compacted, notcompacted, _callback);
                  }
                });
              } else {
                // finished iterating
                return callback(null);
              }
            });
          } else {
            return callback(null);
          }
        }
      });
    });
  };

  /*
    Iterate through files in descending order
    filename.N
    filename.N - 1
    ...
    filename
  */
  Storage.prototype.iterateFiles = function (filename, callback) {
    var files, iterate, next;
    files = [];
    next = () => {
      var _filename;
      _filename = this.nextFilename(files.length, filename);
      return step(function () {
        var _callback;
        _callback = this.parallel();
        path.exists(_filename, function (exists) {
          return _callback(null, exists);
        });
      }, function (err, exists) {
        if (!exists) {
          process.nextTick(iterate);
          return;
        }
        files.push(files.length);
        return process.nextTick(next);
      });
    };
    iterate = function () {
      var file;
      file = files.pop();
      if (file == null) {
        file = null;
      }
      return step(function () {
        return this.parallel()(null, file);
      }, callback, function (err) {
        if (err) {
          return callback(err);
        } else if (file !== null) {
          return process.nextTick(iterate);
        }
      });
    };
    return next();
  };

  /*
  Add index to the end of filename,
  open it if exists and store size
  */
  Storage.prototype.openFile = function (callback) {
    var file, filename, files, padding, that;
    that = this;
    padding = this.padding;
    files = this.files;
    filename = this.nextFilename();
    file = {};
    return step(function () {
      var _callback;
      _callback = this.parallel();
      path.exists(filename, function (exists) {
        return _callback(null, exists);
      });
    }, function (err, exists) {
      if (err) {
        this.paralell()(err);
        return;
      }
      if (!exists) {
        this.parallel()(null);
        return;
      }
      fs.open(filename, 'a+', 0o0666, this.parallel());
      fs.stat(filename, this.parallel());
    }, function (err, fd, stat) {
      var index, paddBuff;
      if (err) {
        throw err;
      }
      if (!(fd && stat)) {
        this.parallel()(null);
        return;
      }
      index = files.length;
      file = {
        filename: filename,
        fd: fd,
        size: stat.size,
        index: index
      };
      if (file.size % padding) {
        paddBuff = new Buffer(padding - file.size % padding);
        fs.write(fd, paddBuff, 0, paddBuff.length, null, this.parallel());
      } else {
        this.parallel()(null, 0);
      }
      this.parallel()(null, file);
      files.push(file);
    }, function (err, bytesWritten, file) {
      if (err) {
        throw err;
      }
      if (bytesWritten != null) {
        if (file.size % padding) {
          if (bytesWritten !== padding - file.size % padding) {
            this.parallel()('Can\'t add padding to db file');
            return;
          }
          file.size += padding - file.size % padding;
        }
        return that.openFile(this.parallel());
      } else {
        return this.parallel()(null);
      }
    }, callback);
  };

  /*
  Create file
  */
  Storage.prototype.createFile = function (writeRoot, callback) {
    var filename;
    filename = this.nextFilename();
    if (callback == null) {
      callback = writeRoot;
      writeRoot = true;
    }
    return fs.open(filename, 'w+', 0o0666, (err, fd) => {
      var file;
      if (err) {
        return callback(err);
      }
      file = {
        filename: filename,
        fd: fd,
        size: 0,
        index: this.files.length - this.filesOffset
      };
      this.files.push(file);
      if (!writeRoot) {
        return callback(null, this);
      }
      this.root_pos = ['0', '2', '0'];
      this.root_pos_data = null;
      // Write new root
      return this.write([], (err, pos) => {
        if (err) {
          return callback(err);
        }
        return this.writeRoot(pos, err => {
          if (err) {
            return callback(err);
          }
          return callback(null, this);
        });
      });
    });
  };

  /*
    Read data from position
  */
  Storage.prototype.read = function (pos, callback, raw) {
    var buff, cached, e, f, file, l, s;
    if (!isPosition(pos)) {
      return callback('pos should be a valid position (read)');
    }
    s = pos[0];
    l = pos[1];
    f = pos[2];
    file = this.files[f || 0];
    buff = new Buffer(l);
    if (!file) {
      return callback('pos is incorrect');
    }
    cached = this.buffersHashmap[pos.join('-')];
    if (cached) {
      try {
        if (!raw) {
          cached = packer.unpack(cached);
        }
        callback(null, cached);
        return;
      } catch (error) {
        e = error;
      }
    }
    return fs.read(file.fd, buff, 0, l, s, function (err, bytesRead) {
      if (err) {
        return callback(err);
      }
      if (bytesRead !== l) {
        return callback('Read less bytes than expected');
      }
      if (!raw) {
        try {
          buff = packer.unpack(buff);
          err = null;
        } catch (error) {
          e = error;
          err = 'Data is not a valid json';
        }
      }
      return callback(err, buff);
    });
  };

  /*
    Write data and return position
  */
  Storage.prototype.write = function (data, callback, raw) {
    if (raw && !Buffer.isBuffer(data)) {
      return callback('In raw mode data should be a buffer');
    }
    if (!raw) {
      data = new Buffer(packer.pack(data));
    }
    return this._fsWrite(data, callback);
  };

  /*
  Read root page
  */
  Storage.prototype.readRoot = function (callback) {
    var cache_callback;
    if (this.root_pos_data) {
      callback(null, this.root_pos_data);
      return;
    }
    cache_callback = (err, data) => {
      if (err) {
        return callback(err);
      }
      this.root_pos_data = data;
      callback(null, data);
    };
    if (this.root_pos) {
      this.read(this.root_pos, cache_callback);
      return;
    }
    return this.readRootPos((err, pos) => {
      if (err) {
        return callback(err);
      }
      return this.read(pos, cache_callback);
    });
  };

  /*
    Find last root in files and return it to callback
     it will be synchronous for now
    TODO: make it asynchronous
  */
  Storage.prototype.readRootPos = function (callback) {
    var checkHash, iterate;
    iterate = (index, callback) => {
      var buff, bytesRead, data, e, file, offset, root;
      file = this.files[index];
      if (!file) {
        return callback('root not found');
      }
      buff = new Buffer(this.rootSize);
      // If file has incorrect size (unpadded)
      // Substract difference from its size
      // B/c root can't be in that unpadded area
      offset = file.size - file.size % this.padding - this.rootSize + this.padding;
      while ((offset -= this.padding) >= 0) {
        bytesRead = fs.readSync(file.fd, buff, 0, this.rootSize, offset);
        if (bytesRead !== this.rootSize) {
          // Header not found
          offset = -1;
          break;
        }
        if (data = checkHash(buff)) {
          root = data;
          try {
            root = packer.unpack(root);
          } catch (error) {
            e = error;
            // Header is not JSON
            // Try in previous file
            offset = -1;
            break;
          }
          return callback(null, root);
        }
      }
      return process.nextTick(function () {
        return iterate(index - 1, callback);
      });
    };
    checkHash = function (buff) {
      var hash, rest;
      hash = buff.slice(0, utils.hash.len).toString();
      rest = buff.slice(utils.hash.len);
      if (hash === utils.hash(rest)) {
        return rest;
      }
    };
    return iterate(this.files.length - 1, callback);
  };

  /*
  Write root page
  */
  Storage.prototype.writeRoot = function (root_pos, callback) {
    var _root_pos, buff, hash;
    if (!isPosition(root_pos)) {
      return callback('pos should be a valid position (writeRoot)');
    }
    _root_pos = packer.pack(root_pos);
    buff = new Buffer(this.rootSize);
    _root_pos.copy(buff, utils.hash.len);
    hash = utils.hash(buff.slice(utils.hash.len));
    buff.write(hash, 0, 'binary');
    return this._fsBuffer(buff, true, err => {
      if (err) {
        return callback(err);
      }
      this.root_pos = root_pos;
      this.root_pos_data = null;
      return callback(null);
    });
  };

  /*
    Low-level write
     buff - is Buffer
   */
  Storage.prototype._fsWrite = function (buff, callback) {
    var file, pos;
    file = this.currentFile();
    pos = [file.size, buff.length, file.index];
    file.size += buff.length;
    this.buffersHashmap[pos.join('-')] = buff;
    return this._fsBuffer(buff, false, function (err) {
      return callback(err, pos);
    });
  };

  /*
    Low-level bufferization
  */
  Storage.prototype._fsBuffer = function (buff, isRoot, callback) {
    var buffLen, delta, fd, file;
    file = this.currentFile();
    fd = file.fd;
    buffLen = buff.length;
    if (isRoot) {
      if (file.size % this.padding) {
        delta = this.padding - file.size % this.padding;
        buffLen += delta;
        this.buffers.push(new Buffer(delta));
      }
      file.size += buffLen;
    }
    this.buffers.push(buff);
    if ((this.buffersBytes += buffLen) < this.flushMinBytes) {
      callback(null);
      return;
    }
    return this._fsFlush(callback);
  };

  /*
  Flush buffered data to disk
  */
  Storage.prototype._fsFlush = function (callback, compacting) {
    var buff, buffLen, buffers, fd, file, i, j, offset, ref;
    file = this.currentFile();
    fd = file.fd;
    buffLen = this.buffersBytes;
    buff = new Buffer(buffLen);
    offset = 0;
    buffers = this.buffers;
    for (i = j = 0, ref = buffers.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      buffers[i].copy(buff, offset);
      offset += buffers[i].length;
    }
    this.buffers = [];
    this.buffersBytes = 0;
    this.buffersHashmap = {};
    return fs.write(fd, buff, 0, buffLen, null, (err, bytesWritten) => {
      if (err || bytesWritten !== buffLen) {
        this._fsCheckSize(function (err2) {
          return callback(err2 || err || 'Written less bytes than expected');
        });
        return;
      }
      if (file.size >= this.partitionSize && !compacting) {
        return this.createFile(false, callback);
      } else {
        return callback(null);
      }
    });
  };

  /*
    Recheck current file's length
  */
  Storage.prototype._fsCheckSize = function (callback) {
    var file, filename;
    file = this.currentFile();
    filename = this.nextFilename(this.file.index);
    return fs.stat(filename, (err, stat) => {
      if (err) {
        return callback(err);
      }
      file.size = stat.size;
      return callback(null);
    });
  };

  /*
    Current file
  */
  Storage.prototype.currentFile = function () {
    return this.files[this.files.length - 1];
  };

  /*
  Close all fds
  */
  Storage.prototype.close = function (callback) {
    var files;
    files = this.files;
    return this._fsFlush(function (err) {
      if (err) {
        return callback(err);
      }
      return step(function () {
        var group, i, j, ref, results;
        group = this.group();
        results = [];
        for (i = j = 0, ref = files.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          if (files[i]) {
            results.push(fs.close(files[i].fd, group()));
          } else {
            results.push(void 0);
          }
        }
        return results;
      }, callback);
    });
  };

  /*
    Compaction flow actions
  */
  Storage.prototype.beforeCompact = function (callback) {
    this.filename += '.compact';
    this.filesOffset = this.files.length;
    return this._fsFlush(err => {
      if (err) {
        return callback(err);
      }
      return this.createFile(false, callback);
    }, true);
  };

  Storage.prototype.afterCompact = function (callback) {
    var files, filesOffset, that;
    that = this;
    filesOffset = this.filesOffset;
    files = this.files;
    this.filename = this.filename.replace(/\.compact$/, '');
    return this._fsFlush(err => {
      if (err) {
        return callback(err);
      }
      return step(function () {
        var i, j, ref;
        for (i = j = 0, ref = files.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          fs.close(files[i].fd, this.parallel());
        }
      }, function (err) {
        var i, j, ref;
        if (err) {
          throw err;
        }
        for (i = j = 0, ref = filesOffset; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          fs.unlink(files[i].filename, this.parallel());
        }
      }, function (err) {
        var compactedCount, fnsQueue, i, j, ref, ref1;
        if (err) {
          throw err;
        }
        fnsQueue = [];
        compactedCount = files.length - filesOffset;
        (function () {
          var results = [];
          for (var j = 0; 0 <= compactedCount ? j < compactedCount : j > compactedCount; 0 <= compactedCount ? j++ : j--) {
            results.push(j);
          }
          return results;
        }).apply(this).forEach(function (i) {
          var compactedName, normalName;
          compactedName = files[i + filesOffset].filename;
          normalName = files[i].filename;
          files[i] = files[i + filesOffset];
          files[i].filename = normalName;
          return fnsQueue.unshift(function (err) {
            if (err) {
              throw err;
            }
            fs.rename(compactedName, normalName, this.parallel());
          });
        });
        fnsQueue.push(this.parallel());
        step.apply(null, fnsQueue);
        for (i = j = ref = compactedCount, ref1 = files.length; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
          files.pop();
        }
        that.filesOffset = 0;
      }, function (err) {
        var ref;
        if (err) {
          throw err;
        }
        (function () {
          var results = [];
          for (var j = 0, ref = files.length; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--) {
            results.push(j);
          }
          return results;
        }).apply(this).forEach(i => {
          var file, fn;
          file = files[i];
          fn = this.parallel();
          return fs.open(file.filename, 'a+', 0o0666, function (err, fd) {
            file.fd = fd;
            return fn(err, file);
          });
        });
      }, function (err) {
        if (err) {
          step(function () {
            var i, j, ref;
            for (i = j = 0, ref = files.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
              fs.close(files[i].fd, this.parallel());
            }
          }, function () {
            that._init(this.parallel());
          }, this.parallel());
          return;
        }
        return null;
      }, callback);
    });
  };
}).call(this);
// Generated by CoffeeScript 2.3.1
(function () {
  /*
    Memory storage for Node Index Module
     This software is licensed under the MIT License.
     Copyright Fedor Indutny, 2011.
     Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to permit
    persons to whom the Software is furnished to do so, subject to the
    following conditions:
     The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.
     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
  /*
    Class @constructor
  */
  var Position, Storage, isPosition, step, util;

  util = require('util');

  step = require('step');

  Storage = exports.Storage = function (options) {
    this.data = [[]];
    this.root_pos = new Position(0);
    return this;
  };

  /*
  @constructor wrapper
  */
  exports.createStorage = function (options) {
    return new Storage(options);
  };

  Storage.prototype.isPosition = isPosition = function (pos) {
    return pos instanceof Position;
  };

  Storage.prototype.read = function (pos, callback) {
    if (!isPosition(pos)) {
      return callback('pos should be a valid position');
    }
    return process.nextTick(() => {
      return callback(null, this.data[pos.index]);
    });
  };

  Storage.prototype.write = function (data, callback) {
    return process.nextTick(() => {
      return callback(null, new Position(this.data.push(data) - 1));
    });
  };

  Storage.prototype.readRoot = function (callback) {
    return process.nextTick(() => {
      return callback(null, this.data[this.root_pos.index]);
    });
  };

  Storage.prototype.writeRoot = function (root_pos, callback) {
    if (!isPosition(root_pos)) {
      return callback('pos should be a valid position');
    }
    return process.nextTick(() => {
      this.root_pos = root_pos;
      return callback(null);
    });
  };

  Storage.prototype.inspect = function () {
    this.data.forEach(function (line, i) {
      return util.puts(i + ': ' + JSON.stringify(line));
    });
    return util.puts('Root : ' + JSON.stringify(this.root_pos));
  };

  Position = exports.Position = function (index) {
    this.index = index;
    return this;
  };

  /*
  Storage state
  */
  Storage.prototype.getState = function () {
    return {};
  };

  Storage.prototype.setState = function (state) {
    return true;
  };

  /*
  Compaction flow
  */
  Storage.prototype.beforeCompact = function (callback) {
    this._compactEdge = this.data.push('--------');
    return callback(null);
  };

  Storage.prototype.afterCompact = function (callback) {
    var i, j, ref;
    for (i = j = 0, ref = this._compactEdge; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      this.data[i] = 0;
    }
    return callback(null);
  };
}).call(this);
// Generated by CoffeeScript 2.3.1
(function () {
  /*
    Various utilities for Node index library
     This software is licensed under the MIT License.
     Copyright Fedor Indutny, 2011.
     Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to permit
    persons to whom the Software is furnished to do so, subject to the
    following conditions:
     The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.
     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
  /*
   Merge two objects
  */
  var crypto, merge, utils;

  crypto = require('crypto');

  utils = exports;

  merge = utils.merge = function (a, b) {
    var c, k, v;
    if (!(a && b)) {
      return a || b || {};
    }
    c = {};
    for (k in a) {
      v = a[k];
      if (!a.hasOwnProperty(k)) {
        continue;
      }
      c[k] = v;
    }
    for (k in b) {
      v = b[k];
      if (!b.hasOwnProperty(k)) {
        continue;
      }
      c[k] = typeof c[k] === 'object' ? merge(c[k], v) : v;
    }
    return c;
  };

  /*
  Perform a binary search in following array
  [[key, value], [key, value], ...]
   @return value or undefined.
  */
  utils.search = function (index, sort, key) {
    var i, len;
    len = index.length - 1;
    i = len;
    while (i >= 0 && sort(index[i][0], key) > 0) {
      i--;
    }
    if (i === len && len >= 0 && sort(index[i][0], key) === 0) {
      null;
    }
    if (i < 0) {
      return null;
    } else {
      return i;
    }
  };

  /*
    Hash function wrapper
  */
  utils.hash = function (data) {
    var hash;
    hash = crypto.createHash('md5');
    hash.update(data);
    return hash.digest('hex');
  };

  utils.hash.len = 32;
}).call(this);
// Generated by CoffeeScript 2.3.1
(function () {
  /*
    Node index - Main Library file
     This software is licensed under the MIT License.
     Copyright Fedor Indutny, 2011.
     Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to permit
    persons to whom the Software is furnished to do so, subject to the
    following conditions:
     The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.
     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
  /*
  Class @constructor
  */
  var DEFAULT_OPTIONS, Index, step, utils;

  step = require('step');

  utils = require('./index/utils');

  DEFAULT_OPTIONS = {
    sort: function (a, b) {
      if (a === null || a < b) {
        return -1;
      } else {
        if (a === b) {
          return 0;
        } else {
          return 1;
        }
      }
    },
    order: 64
  };

  Index = exports.Index = function (options) {
    options = utils.merge(DEFAULT_OPTIONS, options);
    this.storage = options.storage || require('./index/memory-storage').createStorage();
    ({ order: this.order, sort: this.sort, conflictManager: this.conflictManager } = options);
    this.order--;
    this.lockQueue = [];
    return this;
  };

  /*
  Wrapper for class @constructor
  */
  exports.createIndex = function (options) {
    return new Index(options);
  };

  /*
   Get functionality
  */
  Index.prototype.get = require('./index/core/get').get;

  Index.prototype.traverse = require('./index/core/get').traverse;

  Index.prototype.rangeGet = require('./index/core/get').rangeGet;

  /*
    Set functionality
  */
  Index.prototype.set = require('./index/core/set').set;

  /*
    Unset functionality
  */
  Index.prototype.unset = require('./index/core/unset').unset;

  /*
    Compaction functionality
  */
  Index.prototype.compact = require('./index/core/compact').compact;

  /*
    Bulk functionality
  */
  Index.prototype.bulk = require('./index/core/bulk').bulk;

  /*
    Lock functionality
  */
  Index.prototype.lock = function (fn) {
    if (this.locked) {
      this.lockQueue.push(fn);
      return true;
    }
    this.locked = true;
    return false;
  };

  /*
  Release lock functionality
  */
  Index.prototype.releaseLock = function () {
    var fn;
    if (!this.locked) {
      return;
    }
    this.locked = false;
    fn = this.lockQueue.shift();
    if (!fn && this.lockQueue.length <= 0) {
      return;
    }
    return process.nextTick(fn);
  };

  /*
  Export storages
  */
  exports.storage = {
    memory: require('./index/memory-storage'),
    file: require('./index/file-storage')
  };
}).call(this);
